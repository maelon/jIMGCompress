(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["jimgcompress"] = factory();
	else
		root["jimgcompress"] = factory();
})(typeof self !== 'undefined' ? self : this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/*===================================================================
#    FileName: jIMGCompress.js
#      Author: Maelon.J
#       Email: maelon.j@gmail.com
#  CreateTime: 2016-04-06 10:22
# Description: 图片压缩工具
===================================================================*/

var IMGCompress = function () {
    function IMGCompress() {
        _classCallCheck(this, IMGCompress);

        this._option = {
            'width': 600,
            'quality': 0.9
        };
        this._fileName = ''; //文件名
        this._fileType = ''; //文件类型
        this._fileSize = 0; //压缩后文件容量(字节)
        this._width = 0; //压缩后文件宽度
        this._height = 0; //压缩后文件高度
        this._originFileSize = 0; //原始图片容量(字节)
        this._originWidth = 0; //原始图片宽度
        this._originHeight = 0; //原始图片高度
        this._blob = null; //压缩后文件blob对象，可以放在formdata提交
        this._dataURL = ''; //压缩后文件data URL 
        this._originDataURL = ''; //原始文件data URL 

        /**
         * 文件类型枚举
         */
        this._fileTypeEnum = {
            'ffd8ffe*********': 'image/jpeg',
            '89504e470d0a1a0a': 'image/png',
            '474946**********': 'image/gif',
            '424d************': 'image/bmp'
        };

        /**
        * 文件后缀名枚举
        */
        this._fileExtEnum = {
            'image/jpeg': 'jpg',
            'image/png': 'png',
            'image/gif': 'gif',
            'image/bmp': 'bmp'
        };
    }

    /**
    * @public
    * @param {File} file - 传入input的file对象
    * @param {Object} option - 压缩配置
    * @param {number} option.width - 最大压缩宽度 默认600
    * @param {number} option.height - 最大压缩高度 默认自适应(不设置或者为'auto')
    * @param {number} option.quality - 压缩质量 默认0.9(0~1)
    * @param {number} option.limitSize - 最大图片容量(字节) 默认无限制(最小值为1024)
    * @param {Function} callback - 压缩完成回调
    * @param {Function} errorback - 发生错误回调
    *
    * callback回调结果: {
    *   fileName: 文件名
    *   fileSize: 压缩后文件容量(字节)
    *   fileType: 原始文件类型
    *   width: 压缩后文件宽度
    *   height: 压缩后文件高度
    *   originFileSize: 原始图片容量(字节)
    *   originWidth: 原始图片宽度
    *   originHeight: 原始图片高度
    *   blob: 压缩后文件blob对象，可以放在formdata提交
    *   dataURL: 压缩后文件data URL
    *   originDataURL: 原始文件data URL
    * }
    *
    * !!!!!注意!!!!!
    * 文件最后全部转为image/jpeg格式
    */


    _createClass(IMGCompress, [{
        key: 'compress',
        value: function compress(file, option, callback, errorback) {
            var _this = this;

            if (file) {
                if (file instanceof File) {
                    if (file.size) {
                        Object.assign(this._option, option);
                        if (this._option['quality'] > 1 || this._option['quality'] < 0) {
                            this._option['quality'] = 0.9;
                        }
                        if (this._option['limitSize'] < 1024) {
                            this._option['limitSize'] = 1024;
                        }
                        var finishCall = function finishCall() {
                            var fr = new FileReader();
                            fr.addEventListener('load', function (e) {
                                _this._originDataURL = e.target.result;
                                callback({
                                    fileName: _this._fileName,
                                    fileType: _this._fileType,
                                    fileSize: _this._fileSize,
                                    width: _this._width,
                                    height: _this._height,
                                    originFileSize: _this._originFileSize,
                                    originWidth: _this._originWidth,
                                    originHeight: _this._originHeight,
                                    blob: _this._blob,
                                    dataURL: _this._dataURL,
                                    originDataURL: _this._originDataURL
                                });
                            });
                            fr.readAsDataURL(file);
                        };
                        this._checkFileType(file, function (type, name) {
                            _this._fileType = type;
                            _this._fileName = name;
                            _this._originFileSize = file.size;
                            var blob = new Blob([file], { type: type });
                            _this._compress(blob, finishCall, errorback);
                        }, function (error) {
                            _this._throwError(error, errorback);
                        });
                    } else {
                        var error = {
                            type: 'emptyfile',
                            msg: 'file error: file content is empty'
                        };
                        this._throwError(error, errorback);
                    }
                } else {
                    var _error = {
                        type: 'notfile',
                        msg: 'argument type error: not a File type'
                    };
                    this._throwError(_error, errorback);
                }
            } else {
                var _error2 = {
                    type: 'nofile',
                    msg: 'argument error: file is null'
                };
                this._throwError(_error2, errorback);
            }
        }

        /**
         * @public
         * @description 添加头信息描述
         * @param {string} feature - 16进制头信息，可用*
         * @param {string} type - 类型
         * @param {string} ext - 后缀名
         */

    }, {
        key: 'addFileHeaderEnum',
        value: function addFileHeaderEnum(feature, type, ext) {
            if (typeof feature === 'string' && typeof type === 'string' && /image\/\w+/.test(type) && typeof ext === 'string') {
                this._fileTypeEnum[feature] = type;
                this._fileExtEnum[type] = ext;
            }
        }

        /**
         * @private
         * @description 检测文件类型
         */

    }, {
        key: '_checkFileType',
        value: function _checkFileType(file, callback, errorback) {
            var _this2 = this;

            if (file.type !== '') {
                callback(file.type, file.name);
            } else {
                try {
                    var fr = new FileReader();
                    fr.addEventListener('load', function (e) {
                        var buffer = e.target.result;

                        //文件头信息判断文件类型，如果直接获取不到文件类型
                        try {
                            (function () {
                                var data = new DataView(buffer, 0);
                                var bts = [];
                                //获取文件前8个字节，转成16进制字符串，并与fileTypeEnum匹配

                                var _loop = function _loop(i) {
                                    bts.push(function () {
                                        var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '0' + data.getUint8(i).toString(16);
                                        return val.substring(val.length - 2);
                                    }());
                                };

                                for (var i = 0; i < 8; i++) {
                                    _loop(i);
                                }
                                var typeFeature = bts.join('');
                                var type = '';
                                for (var s in _this2._fileTypeEnum) {
                                    var regexp = new RegExp('^' + s.replace(/\*/gi, '\\w') + '$', 'ig');
                                    if (regexp.test(typeFeature)) {
                                        type = _this2._fileTypeEnum[s];
                                        break;
                                    }
                                }
                                if (type) {
                                    callback(type, file.name + '.' + _this2._fileExtEnum[type]);
                                } else {
                                    var error = {
                                        type: 'badfiletype',
                                        msg: 'file type error: cannot analysis file type'
                                    };
                                    _this2._throwError(error, errorback);
                                }
                            })();
                        } catch (e) {
                            var error = {
                                type: 'apierror',
                                msg: 'api error: not support DataView api'
                            };
                            _this2._throwError(error, errorback);
                        }
                    });
                    fr.readAsArrayBuffer(file);
                } catch (e) {
                    var error = {
                        type: 'apierror',
                        msg: 'api error: not support FileReader api'
                    };
                    this._throwError(error, errorback);
                }
            }
        }

        /**
         * @private
         * @description 使用canvas压缩出jpg
         */

    }, {
        key: '_compress',
        value: function _compress(blob, callback, errorback) {
            var _this3 = this;

            try {
                this._originFileSize = blob.size;
                var image = document.createElement('img');
                var url = URL.createObjectURL(blob);
                image.addEventListener('load', function (e) {
                    URL.revokeObjectURL(url);
                    var img = e.target;
                    _this3._originWidth = img.naturalWidth;
                    _this3._originHeight = img.naturalHeight;
                    var width = void 0;
                    var height = void 0;
                    var oWidth = _this3._option['width'];
                    var oHeight = _this3._option['height'];
                    if (oWidth !== undefined && oWidth !== 'auto' && (oHeight === undefined || oHeight === 'auto')) {
                        //如果只设置了宽度
                        width = parseInt(oWidth);
                        _this3._originWidth < width && (width = _this3._originWidth);
                        height = Math.floor(width * _this3._originHeight / _this3._originWidth);
                    } else if (oHeight === undefined && oHeight !== 'auto' && (oWidth === undefined || oWidth === 'auto')) {
                        //如果只设置了高度
                        height = parseInt(oHeight);
                        _this3._originHeight < height && (height = _this3._originHeight);
                        width = Math.floor(height * _this3._originWidth / _this3._originHeight);
                    } else if (oWidth !== undefined && oWidth !== 'auto' && oHeight !== undefined && oHeight !== 'auto') {
                        //如果设置了宽度、高度
                        width = parseInt(oWidth);
                        height = parseInt(oHeight);
                        if (width * _this3._originHeight / _this3._originWidth > height) {
                            width = Math.floor(height * _this3._originWidth / _this3._originHeight);
                            if (width > _this3._originWidth) {
                                width = _this3._originWidth;
                                height = _this3._originHeight;
                            }
                        } else {
                            height = Math.floor(width * _this3._originHeight / _this3._originWidth);
                            if (height > _this3._originHeight) {
                                width = _this3._originWidth;
                                height = _this3._originHeight;
                            }
                        }
                    } else {
                        width = _this3._originWidth;
                        height = _this3._originHeight;
                    }
                    var dataurl = _this3._compressByCanvas(img, width, height, _this3._option['quality']);
                    var blob = _this3._dataURL2Blob(dataurl);
                    while (blob.size > _this3._option['limitSize']) {
                        width = Math.floor(0.8 * width);
                        height = Math.floor(0.8 * height);
                        dataurl = _this3._compressByCanvas(img, width, height, _this3._option['quality']);
                        blob = _this3._dataURL2Blob(dataurl);
                    }
                    //压缩完成
                    _this3._fileSize = blob.size;
                    _this3._width = width;
                    _this3._height = height;
                    _this3._blob = blob;
                    _this3._dataURL = dataurl;
                    callback('finish');
                });
                image.src = url;
            } catch (e) {
                var error = {
                    type: 'apierror',
                    msg: 'api error: not support canvas or URL api'
                };
                this._throwError(error, errorback);
            }
        }

        /**
         * @private
         * @description使用canvas进行压缩
         */

    }, {
        key: '_compressByCanvas',
        value: function _compressByCanvas(img, width, height, quality) {
            var canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            var context = canvas.getContext('2d');
            context.fillStyle = '#FFF';
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.drawImage(img, 0, 0, canvas.width, canvas.height);
            var dataurl = canvas.toDataURL('image/jpeg', quality);
            return dataurl;
        }

        /**
         * @private
         * @description 转data url为blob
         */

    }, {
        key: '_dataURL2Blob',
        value: function _dataURL2Blob(dataurl) {
            try {
                var arr = dataurl.split(',');
                var mime = arr[0].match(/:(.*?);/)[1];
                var bstr = atob(arr[1]);
                var n = bstr.length;
                var u8arr = new Uint8Array(n);
                while (n--) {
                    u8arr[n] = bstr.charCodeAt(n);
                }
                return new Blob([u8arr], { type: mime });
            } catch (e) {
                var error = {
                    type: 'apierror',
                    msg: 'api error: not support atob or Unit8Array api'
                };
                this._throwError(error, errorback);
            }
        }

        /**
         * @private
         * @description 抛出异常，或异常回调
         */

    }, {
        key: '_throwError',
        value: function _throwError() {
            var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            var errorback = arguments[1];

            if (errorback && typeof errorback === 'function') {
                errorback(error);
            } else {
                throw new Error(error['msg']);
            }
        }
    }]);

    return IMGCompress;
}();

exports.default = new IMGCompress();

/***/ })
/******/ ]);
});